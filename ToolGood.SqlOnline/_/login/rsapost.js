var dbits; var canary = 244837814094590; var j_lm = ((canary & 16777215) == 15715070); function BigInteger(E, F, D) { if (E != null) { if ("number" == typeof E) { this.fromNumber(E, F, D) } else { if (F == null && "string" != typeof E) { this.fromString(E, 256) } else { this.fromString(E, F) } } } } function nbi() { return new BigInteger(null) } function am1(L, K, H, I, N, M) { while (--M >= 0) { var J = K * this[L++] + H[I] + N; N = Math.floor(J / 67108864); H[I++] = J & 67108863 } return N } function am2(U, V, O, P, L, R) { var Q = V & 32767, T = V >> 15; while (--R >= 0) { var M = this[U] & 32767; var S = this[U++] >> 15; var N = T * M + S * Q; M = Q * M + ((N & 32767) << 15) + O[P] + (L & 1073741823); L = (M >>> 30) + (N >>> 15) + T * S + (L >>> 30); O[P++] = M & 1073741823 } return L } function am3(U, V, O, P, L, R) { var Q = V & 16383, T = V >> 14; while (--R >= 0) { var M = this[U] & 16383; var S = this[U++] >> 14; var N = T * M + S * Q; M = Q * M + ((N & 16383) << 14) + O[P] + L; L = (M >> 28) + (N >> 14) + T * S; O[P++] = M & 268435455 } return L } if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) { BigInteger.prototype.am = am2; dbits = 30 } else { if (j_lm && (navigator.appName != "Netscape")) { BigInteger.prototype.am = am1; dbits = 26 } else { BigInteger.prototype.am = am3; dbits = 28 } } BigInteger.prototype.DB = dbits; BigInteger.prototype.DM = ((1 << dbits) - 1); BigInteger.prototype.DV = (1 << dbits); var BI_FP = 52; BigInteger.prototype.FV = Math.pow(2, BI_FP); BigInteger.prototype.F1 = BI_FP - dbits; BigInteger.prototype.F2 = 2 * dbits - BI_FP; var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"; var BI_RC = new Array(); var rr, vv; rr = "0".charCodeAt(0); for (vv = 0; vv <= 9; ++vv) { BI_RC[rr++] = vv } rr = "a".charCodeAt(0); for (vv = 10; vv < 36; ++vv) { BI_RC[rr++] = vv } rr = "A".charCodeAt(0); for (vv = 10; vv < 36; ++vv) { BI_RC[rr++] = vv } function int2char(B) { return BI_RM.charAt(B) } function intAt(D, F) { var E = BI_RC[D.charCodeAt(F)]; return (E == null) ? -1 : E } function bnpCopyTo(D) { for (var C = this.t - 1; C >= 0; --C) { D[C] = this[C] } D.t = this.t; D.s = this.s } function bnpFromInt(B) { this.t = 1; this.s = (B < 0) ? -1 : 0; if (B > 0) { this[0] = B } else { if (B < -1) { this[0] = B + this.DV } else { this.t = 0 } } } function nbv(D) { var C = nbi(); C.fromInt(D); return C } function bnpFromString(L, J) { var I; if (J == 16) { I = 4 } else { if (J == 8) { I = 3 } else { if (J == 256) { I = 8 } else { if (J == 2) { I = 1 } else { if (J == 32) { I = 5 } else { if (J == 4) { I = 2 } else { this.fromRadix(L, J); return } } } } } } this.t = 0; this.s = 0; var N = L.length, H = false, M = 0; while (--N >= 0) { var K = (I == 8) ? L[N] & 255 : intAt(L, N); if (K < 0) { if (L.charAt(N) == "-") { H = true } continue } H = false; if (M == 0) { this[this.t++] = K } else { if (M + I > this.DB) { this[this.t - 1] |= (K & ((1 << (this.DB - M)) - 1)) << M; this[this.t++] = (K >> (this.DB - M)) } else { this[this.t - 1] |= K << M } } M += I; if (M >= this.DB) { M -= this.DB } } if (I == 8 && (L[0] & 128) != 0) { this.s = -1; if (M > 0) { this[this.t - 1] |= ((1 << (this.DB - M)) - 1) << M } } this.clamp(); if (H) { BigInteger.ZERO.subTo(this, this) } } function bnpClamp() { var B = this.s & this.DM; while (this.t > 0 && this[this.t - 1] == B) { --this.t } } function bnToString(N) { if (this.s < 0) { return "-" + this.negate().toString(N) } var O; if (N == 16) { O = 4 } else { if (N == 8) { O = 3 } else { if (N == 2) { O = 1 } else { if (N == 32) { O = 5 } else { if (N == 4) { O = 2 } else { return this.toRadix(N) } } } } } var K = (1 << O) - 1, I, M = false, L = "", P = this.t; var J = this.DB - (P * this.DB) % O; if (P-- > 0) { if (J < this.DB && (I = this[P] >> J) > 0) { M = true; L = int2char(I) } while (P >= 0) { if (J < O) { I = (this[P] & ((1 << J) - 1)) << (O - J); I |= this[--P] >> (J += this.DB - O) } else { I = (this[P] >> (J -= O)) & K; if (J <= 0) { J += this.DB; --P } } if (I > 0) { M = true } if (M) { L += int2char(I) } } } return M ? L : "0" } function bnNegate() { var B = nbi(); BigInteger.ZERO.subTo(this, B); return B } function bnAbs() { return (this.s < 0) ? this.negate() : this } function bnCompareTo(E) { var F = this.s - E.s; if (F != 0) { return F } var D = this.t; F = D - E.t; if (F != 0) { return (this.s < 0) ? -F : F } while (--D >= 0) { if ((F = this[D] - E[D]) != 0) { return F } } return 0 } function nbits(D) { var F = 1, E; if ((E = D >>> 16) != 0) { D = E; F += 16 } if ((E = D >> 8) != 0) { D = E; F += 8 } if ((E = D >> 4) != 0) { D = E; F += 4 } if ((E = D >> 2) != 0) { D = E; F += 2 } if ((E = D >> 1) != 0) { D = E; F += 1 } return F } function bnBitLength() { if (this.t <= 0) { return 0 } return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM)) } function bnpDLShiftTo(D, F) { var E; for (E = this.t - 1; E >= 0; --E) { F[E + D] = this[E] } for (E = D - 1; E >= 0; --E) { F[E] = 0 } F.t = this.t + D; F.s = this.s } function bnpDRShiftTo(D, F) { for (var E = D; E < this.t; ++E) { F[E - D] = this[E] } F.t = Math.max(this.t - D, 0); F.s = this.s } function bnpLShiftTo(N, L) { var J = N % this.DB; var P = this.DB - J; var K = (1 << P) - 1; var O = Math.floor(N / this.DB), I = (this.s << J) & this.DM, M; for (M = this.t - 1; M >= 0; --M) { L[M + O + 1] = (this[M] >> P) | I; I = (this[M] & K) << J } for (M = O - 1; M >= 0; --M) { L[M] = 0 } L[O] = I; L.t = this.t + O + 1; L.s = this.s; L.clamp() } function bnpRShiftTo(M, L) { L.s = this.s; var N = Math.floor(M / this.DB); if (N >= this.t) { L.t = 0; return } var K = M % this.DB; var I = this.DB - K; var H = (1 << K) - 1; L[0] = this[N] >> K; for (var J = N + 1; J < this.t; ++J) { L[J - N - 1] |= (this[J] & H) << I; L[J - N] = this[J] >> K } if (K > 0) { L[this.t - N - 1] |= (this.s & H) << I } L.t = this.t - N; L.clamp() } function bnpSubTo(G, J) { var H = 0, F = 0, I = Math.min(G.t, this.t); while (H < I) { F += this[H] - G[H]; J[H++] = F & this.DM; F >>= this.DB } if (G.t < this.t) { F -= G.s; while (H < this.t) { F += this[H]; J[H++] = F & this.DM; F >>= this.DB } F += this.s } else { F += this.s; while (H < G.t) { F -= G[H]; J[H++] = F & this.DM; F >>= this.DB } F -= G.s } J.s = (F < 0) ? -1 : 0; if (F < -1) { J[H++] = this.DV + F } else { if (F > 0) { J[H++] = F } } J.t = H; J.clamp() } function bnpMultiplyTo(G, J) { var I = this.abs(), F = G.abs(); var H = I.t; J.t = H + F.t; while (--H >= 0) { J[H] = 0 } for (H = 0; H < F.t; ++H) { J[H + I.t] = I.am(0, F[H], J, H, 0, I.t) } J.s = 0; J.clamp(); if (this.s != G.s) { BigInteger.ZERO.subTo(J, J) } } function bnpSquareTo(H) { var G = this.abs(); var F = H.t = 2 * G.t; while (--F >= 0) { H[F] = 0 } for (F = 0; F < G.t - 1; ++F) { var E = G.am(F, G[F], H, 2 * F, 0, 1); if ((H[F + G.t] += G.am(F + 1, 2 * G[F], H, 2 * F + 1, E, G.t - F - 1)) >= G.DV) { H[F + G.t] -= G.DV; H[F + G.t + 1] = 1 } } if (H.t > 0) { H[H.t - 1] += G.am(F, G[F], H, 2 * F, 0, 1) } H.s = 0; H.clamp() } function bnpDivRemTo(a, f, h) { var Y = a.abs(); if (Y.t <= 0) { return } var W = this.abs(); if (W.t < Y.t) { if (f != null) { f.fromInt(0) } if (h != null) { this.copyTo(h) } return } if (h == null) { h = nbi() } var U = nbi(), k = this.s, Z = a.s; var g = this.DB - nbits(Y[Y.t - 1]); if (g > 0) { Y.lShiftTo(g, U); W.lShiftTo(g, h) } else { Y.copyTo(U); W.copyTo(h) } var T = U.t; var X = U[T - 1]; if (X == 0) { return } var V = X * (1 << this.F1) + ((T > 1) ? U[T - 2] >> this.F2 : 0); var d = this.FV / V, b = (1 << this.F1) / V, e = 1 << this.F2; var j = h.t, i = j - T, l = (f == null) ? nbi() : f; U.dlShiftTo(i, l); if (h.compareTo(l) >= 0) { h[h.t++] = 1; h.subTo(l, h) } BigInteger.ONE.dlShiftTo(T, l); l.subTo(U, U); while (U.t < T) { U[U.t++] = 0 } while (--i >= 0) { var c = (h[--j] == X) ? this.DM : Math.floor(h[j] * d + (h[j - 1] + e) * b); if ((h[j] += U.am(0, c, h, i, 0, T)) < c) { U.dlShiftTo(i, l); h.subTo(l, h); while (h[j] < --c) { h.subTo(l, h) } } } if (f != null) { h.drShiftTo(T, f); if (k != Z) { BigInteger.ZERO.subTo(f, f) } } h.t = T; h.clamp(); if (g > 0) { h.rShiftTo(g, h) } if (k < 0) { BigInteger.ZERO.subTo(h, h) } } function bnMod(C) { var D = nbi(); this.abs().divRemTo(C, null, D); if (this.s < 0 && D.compareTo(BigInteger.ZERO) > 0) { C.subTo(D, D) } return D } function Classic(B) { this.m = B } function cConvert(B) { if (B.s < 0 || B.compareTo(this.m) >= 0) { return B.mod(this.m) } else { return B } } function cRevert(B) { return B } function cReduce(B) { B.divRemTo(this.m, null, B) } function cMulTo(D, E, F) { D.multiplyTo(E, F); this.reduce(F) } function cSqrTo(C, D) { C.squareTo(D); this.reduce(D) } Classic.prototype.convert = cConvert; Classic.prototype.revert = cRevert; Classic.prototype.reduce = cReduce; Classic.prototype.mulTo = cMulTo; Classic.prototype.sqrTo = cSqrTo; function bnpInvDigit() { if (this.t < 1) { return 0 } var D = this[0]; if ((D & 1) == 0) { return 0 } var C = D & 3; C = (C * (2 - (D & 15) * C)) & 15; C = (C * (2 - (D & 255) * C)) & 255; C = (C * (2 - (((D & 65535) * C) & 65535))) & 65535; C = (C * (2 - D * C % this.DV)) % this.DV; return (C > 0) ? this.DV - C : -C } function Montgomery(B) { this.m = B; this.mp = B.invDigit(); this.mpl = this.mp & 32767; this.mph = this.mp >> 15; this.um = (1 << (B.DB - 15)) - 1; this.mt2 = 2 * B.t } function montConvert(C) { var D = nbi(); C.abs().dlShiftTo(this.m.t, D); D.divRemTo(this.m, null, D); if (C.s < 0 && D.compareTo(BigInteger.ZERO) > 0) { this.m.subTo(D, D) } return D } function montRevert(C) { var D = nbi(); C.copyTo(D); this.reduce(D); return D } function montReduce(F) { while (F.t <= this.mt2) { F[F.t++] = 0 } for (var H = 0; H < this.m.t; ++H) { var E = F[H] & 32767; var G = (E * this.mpl + (((E * this.mph + (F[H] >> 15) * this.mpl) & this.um) << 15)) & F.DM; E = H + this.m.t; F[E] += this.m.am(0, G, F, H, 0, this.m.t); while (F[E] >= F.DV) { F[E] -= F.DV; F[++E]++ } } F.clamp(); F.drShiftTo(this.m.t, F); if (F.compareTo(this.m) >= 0) { F.subTo(this.m, F) } } function montSqrTo(C, D) { C.squareTo(D); this.reduce(D) } function montMulTo(D, E, F) { D.multiplyTo(E, F); this.reduce(F) } Montgomery.prototype.convert = montConvert; Montgomery.prototype.revert = montRevert; Montgomery.prototype.reduce = montReduce; Montgomery.prototype.mulTo = montMulTo; Montgomery.prototype.sqrTo = montSqrTo; function bnpIsEven() { return ((this.t > 0) ? (this[0] & 1) : this.s) == 0 } function bnpExp(M, K) { if (M > 4294967295 || M < 1) { return BigInteger.ONE } var L = nbi(), H = nbi(), N = K.convert(this), J = nbits(M) - 1; N.copyTo(L); while (--J >= 0) { K.sqrTo(L, H); if ((M & (1 << J)) > 0) { K.mulTo(H, N, L) } else { var I = L; L = H; H = I } } return K.revert(L) } function bnModPowInt(F, E) { var D; if (F < 256 || E.isEven()) { D = new Classic(E) } else { D = new Montgomery(E) } return this.exp(F, D) } BigInteger.prototype.copyTo = bnpCopyTo; BigInteger.prototype.fromInt = bnpFromInt; BigInteger.prototype.fromString = bnpFromString; BigInteger.prototype.clamp = bnpClamp; BigInteger.prototype.dlShiftTo = bnpDLShiftTo; BigInteger.prototype.drShiftTo = bnpDRShiftTo; BigInteger.prototype.lShiftTo = bnpLShiftTo; BigInteger.prototype.rShiftTo = bnpRShiftTo; BigInteger.prototype.subTo = bnpSubTo; BigInteger.prototype.multiplyTo = bnpMultiplyTo; BigInteger.prototype.squareTo = bnpSquareTo; BigInteger.prototype.divRemTo = bnpDivRemTo; BigInteger.prototype.invDigit = bnpInvDigit; BigInteger.prototype.isEven = bnpIsEven; BigInteger.prototype.exp = bnpExp; BigInteger.prototype.toString = bnToString; BigInteger.prototype.negate = bnNegate; BigInteger.prototype.abs = bnAbs; BigInteger.prototype.compareTo = bnCompareTo; BigInteger.prototype.bitLength = bnBitLength; BigInteger.prototype.mod = bnMod; BigInteger.prototype.modPowInt = bnModPowInt; BigInteger.ZERO = nbv(0); BigInteger.ONE = nbv(1); function bnClone() { var B = nbi(); this.copyTo(B); return B } function bnIntValue() { if (this.s < 0) { if (this.t == 1) { return this[0] - this.DV } else { if (this.t == 0) { return -1 } } } else { if (this.t == 1) { return this[0] } else { if (this.t == 0) { return 0 } } } return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0] } function bnByteValue() { return (this.t == 0) ? this.s : (this[0] << 24) >> 24 } function bnShortValue() { return (this.t == 0) ? this.s : (this[0] << 16) >> 16 } function bnpChunkSize(B) { return Math.floor(Math.LN2 * this.DB / Math.log(B)) } function bnSigNum() { if (this.s < 0) { return -1 } else { if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) { return 0 } else { return 1 } } } function bnpToRadix(J) { if (J == null) { J = 10 } if (this.signum() == 0 || J < 2 || J > 36) { return "0" } var H = this.chunkSize(J); var I = Math.pow(J, H); var N = nbv(I), K = nbi(), M = nbi(), L = ""; this.divRemTo(N, K, M); while (K.signum() > 0) { L = (I + M.intValue()).toString(J).substr(1) + L; K.divRemTo(N, K, M) } return M.intValue().toString(J) + L } function bnpFromRadix(N, P) { this.fromInt(0); if (P == null) { P = 10 } var L = this.chunkSize(P); var K = Math.pow(P, L), R = false, Q = 0, M = 0; for (var O = 0; O < N.length; ++O) { var J = intAt(N, O); if (J < 0) { if (N.charAt(O) == "-" && this.signum() == 0) { R = true } continue } M = P * M + J; if (++Q >= L) { this.dMultiply(K); this.dAddOffset(M, 0); Q = 0; M = 0 } } if (Q > 0) { this.dMultiply(Math.pow(P, Q)); this.dAddOffset(M, 0) } if (R) { BigInteger.ZERO.subTo(this, this) } } function bnpFromNumber(F, J, H) { if ("number" == typeof J) { if (F < 2) { this.fromInt(1) } else { this.fromNumber(F, H); if (!this.testBit(F - 1)) { this.bitwiseTo(BigInteger.ONE.shiftLeft(F - 1), op_or, this) } if (this.isEven()) { this.dAddOffset(1, 0) } while (!this.isProbablePrime(J)) { this.dAddOffset(2, 0); if (this.bitLength() > F) { this.subTo(BigInteger.ONE.shiftLeft(F - 1), this) } } } } else { var I = new Array(), G = F & 7; I.length = (F >> 3) + 1; J.nextBytes(I); if (G > 0) { I[0] &= ((1 << G) - 1) } else { I[0] = 0 } this.fromString(I, 256) } } function bnToByteArray() { var J = this.t, H = new Array(); H[0] = this.s; var I = this.DB - (J * this.DB) % 8, F, G = 0; if (J-- > 0) { if (I < this.DB && (F = this[J] >> I) != (this.s & this.DM) >> I) { H[G++] = F | (this.s << (this.DB - I)) } while (J >= 0) { if (I < 8) { F = (this[J] & ((1 << I) - 1)) << (8 - I); F |= this[--J] >> (I += this.DB - 8) } else { F = (this[J] >> (I -= 8)) & 255; if (I <= 0) { I += this.DB; --J } } if ((F & 128) != 0) { F |= -256 } if (G == 0 && (this.s & 128) != (F & 128)) { ++G } if (G > 0 || F != this.s) { H[G++] = F } } } return H } function bnEquals(B) { return (this.compareTo(B) == 0) } function bnMin(B) { return (this.compareTo(B) < 0) ? this : B } function bnMax(B) { return (this.compareTo(B) > 0) ? this : B } function bnpBitwiseTo(I, K, L) { var J, G, H = Math.min(I.t, this.t); for (J = 0; J < H; ++J) { L[J] = K(this[J], I[J]) } if (I.t < this.t) { G = I.s & this.DM; for (J = H; J < this.t; ++J) { L[J] = K(this[J], G) } L.t = this.t } else { G = this.s & this.DM; for (J = H; J < I.t; ++J) { L[J] = K(G, I[J]) } L.t = I.t } L.s = K(this.s, I.s); L.clamp() } function op_and(D, C) { return D & C } function bnAnd(C) { var D = nbi(); this.bitwiseTo(C, op_and, D); return D } function op_or(D, C) { return D | C } function bnOr(C) { var D = nbi(); this.bitwiseTo(C, op_or, D); return D } function op_xor(D, C) { return D ^ C } function bnXor(C) { var D = nbi(); this.bitwiseTo(C, op_xor, D); return D } function op_andnot(D, C) { return D & ~C } function bnAndNot(C) { var D = nbi(); this.bitwiseTo(C, op_andnot, D); return D } function bnNot() { var D = nbi(); for (var C = 0; C < this.t; ++C) { D[C] = this.DM & ~this[C] } D.t = this.t; D.s = ~this.s; return D } function bnShiftLeft(C) { var D = nbi(); if (C < 0) { this.rShiftTo(-C, D) } else { this.lShiftTo(C, D) } return D } function bnShiftRight(C) { var D = nbi(); if (C < 0) { this.lShiftTo(-C, D) } else { this.rShiftTo(C, D) } return D } function lbit(C) { if (C == 0) { return -1 } var D = 0; if ((C & 65535) == 0) { C >>= 16; D += 16 } if ((C & 255) == 0) { C >>= 8; D += 8 } if ((C & 15) == 0) { C >>= 4; D += 4 } if ((C & 3) == 0) { C >>= 2; D += 2 } if ((C & 1) == 0) { ++D } return D } function bnGetLowestSetBit() { for (var B = 0; B < this.t; ++B) { if (this[B] != 0) { return B * this.DB + lbit(this[B]) } } if (this.s < 0) { return this.t * this.DB } return -1 } function cbit(C) { var D = 0; while (C != 0) { C &= C - 1; ++D } return D } function bnBitCount() { var F = 0, E = this.s & this.DM; for (var D = 0; D < this.t; ++D) { F += cbit(this[D] ^ E) } return F } function bnTestBit(D) { var C = Math.floor(D / this.DB); if (C >= this.t) { return (this.s != 0) } return ((this[C] & (1 << (D % this.DB))) != 0) } function bnpChangeBit(D, E) { var F = BigInteger.ONE.shiftLeft(D); this.bitwiseTo(F, E, F); return F } function bnSetBit(B) { return this.changeBit(B, op_or) } function bnClearBit(B) { return this.changeBit(B, op_andnot) } function bnFlipBit(B) { return this.changeBit(B, op_xor) } function bnpAddTo(G, J) { var H = 0, F = 0, I = Math.min(G.t, this.t); while (H < I) { F += this[H] + G[H]; J[H++] = F & this.DM; F >>= this.DB } if (G.t < this.t) { F += G.s; while (H < this.t) { F += this[H]; J[H++] = F & this.DM; F >>= this.DB } F += this.s } else { F += this.s; while (H < G.t) { F += G[H]; J[H++] = F & this.DM; F >>= this.DB } F += G.s } J.s = (F < 0) ? -1 : 0; if (F > 0) { J[H++] = F } else { if (F < -1) { J[H++] = this.DV + F } } J.t = H; J.clamp() } function bnAdd(C) { var D = nbi(); this.addTo(C, D); return D } function bnSubtract(C) { var D = nbi(); this.subTo(C, D); return D } function bnMultiply(C) { var D = nbi(); this.multiplyTo(C, D); return D } function bnSquare() { var B = nbi(); this.squareTo(B); return B } function bnDivide(C) { var D = nbi(); this.divRemTo(C, D, null); return D } function bnRemainder(C) { var D = nbi(); this.divRemTo(C, null, D); return D } function bnDivideAndRemainder(E) { var D = nbi(), F = nbi(); this.divRemTo(E, D, F); return new Array(D, F) } function bnpDMultiply(B) { this[this.t] = this.am(0, B - 1, this, 0, 0, this.t); ++this.t; this.clamp() } function bnpDAddOffset(D, C) { if (D == 0) { return } while (this.t <= C) { this[this.t++] = 0 } this[C] += D; while (this[C] >= this.DV) { this[C] -= this.DV; if (++C >= this.t) { this[this.t++] = 0 } ++this[C] } } function NullExp() { } function nNop(B) { return B } function nMulTo(D, E, F) { D.multiplyTo(E, F) } function nSqrTo(C, D) { C.squareTo(D) } NullExp.prototype.convert = nNop; NullExp.prototype.revert = nNop; NullExp.prototype.mulTo = nMulTo; NullExp.prototype.sqrTo = nSqrTo; function bnPow(B) { return this.exp(B, new NullExp()) } function bnpMultiplyLowerTo(F, H, J) { var I = Math.min(this.t + F.t, H); J.s = 0; J.t = I; while (I > 0) { J[--I] = 0 } var G; for (G = J.t - this.t; I < G; ++I) { J[I + this.t] = this.am(0, F[I], J, I, 0, this.t) } for (G = Math.min(F.t, H) ; I < G; ++I) { this.am(0, F[I], J, I, 0, H - I) } J.clamp() } function bnpMultiplyUpperTo(E, F, H) { --F; var G = H.t = this.t + E.t - F; H.s = 0; while (--G >= 0) { H[G] = 0 } for (G = Math.max(F - this.t, 0) ; G < E.t; ++G) { H[this.t + G - F] = this.am(F - G, E[G], H, 0, 0, this.t + G - F) } H.clamp(); H.drShiftTo(1, H) } function Barrett(B) { this.r2 = nbi(); this.q3 = nbi(); BigInteger.ONE.dlShiftTo(2 * B.t, this.r2); this.mu = this.r2.divide(B); this.m = B } function barrettConvert(C) { if (C.s < 0 || C.t > 2 * this.m.t) { return C.mod(this.m) } else { if (C.compareTo(this.m) < 0) { return C } else { var D = nbi(); C.copyTo(D); this.reduce(D); return D } } } function barrettRevert(B) { return B } function barrettReduce(B) { B.drShiftTo(this.m.t - 1, this.r2); if (B.t > this.m.t + 1) { B.t = this.m.t + 1; B.clamp() } this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3); this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); while (B.compareTo(this.r2) < 0) { B.dAddOffset(1, this.m.t + 1) } B.subTo(this.r2, B); while (B.compareTo(this.m) >= 0) { B.subTo(this.m, B) } } function barrettSqrTo(C, D) { C.squareTo(D); this.reduce(D) } function barrettMulTo(D, E, F) { D.multiplyTo(E, F); this.reduce(F) } Barrett.prototype.convert = barrettConvert; Barrett.prototype.revert = barrettRevert; Barrett.prototype.reduce = barrettReduce; Barrett.prototype.mulTo = barrettMulTo; Barrett.prototype.sqrTo = barrettSqrTo; function bnModPow(Y, Q) { var R = Y.bitLength(), b, Z = nbv(1), W; if (R <= 0) { return Z } else { if (R < 18) { b = 1 } else { if (R < 48) { b = 3 } else { if (R < 144) { b = 4 } else { if (R < 768) { b = 5 } else { b = 6 } } } } } if (R < 8) { W = new Classic(Q) } else { if (Q.isEven()) { W = new Barrett(Q) } else { W = new Montgomery(Q) } } var U = new Array(), S = 3, T = b - 1, e = (1 << b) - 1; U[1] = W.convert(this); if (b > 1) { var V = nbi(); W.sqrTo(U[1], V); while (S <= e) { U[S] = nbi(); W.mulTo(V, U[S - 2], U[S]); S += 2 } } var a = Y.t - 1, c, X = true, f = nbi(), d; R = nbits(Y[a]) - 1; while (a >= 0) { if (R >= T) { c = (Y[a] >> (R - T)) & e } else { c = (Y[a] & ((1 << (R + 1)) - 1)) << (T - R); if (a > 0) { c |= Y[a - 1] >> (this.DB + R - T) } } S = b; while ((c & 1) == 0) { c >>= 1; --S } if ((R -= S) < 0) { R += this.DB; --a } if (X) { U[c].copyTo(Z); X = false } else { while (S > 1) { W.sqrTo(Z, f); W.sqrTo(f, Z); S -= 2 } if (S > 0) { W.sqrTo(Z, f) } else { d = Z; Z = f; f = d } W.mulTo(f, U[c], Z) } while (a >= 0 && (Y[a] & (1 << R)) == 0) { W.sqrTo(Z, f); d = Z; Z = f; f = d; if (--R < 0) { R = this.DB - 1; --a } } } return W.revert(Z) } function bnGCD(G) { var K = (this.s < 0) ? this.negate() : this.clone(); var H = (G.s < 0) ? G.negate() : G.clone(); if (K.compareTo(H) < 0) { var I = K; K = H; H = I } var J = K.getLowestSetBit(), L = H.getLowestSetBit(); if (L < 0) { return K } if (J < L) { L = J } if (L > 0) { K.rShiftTo(L, K); H.rShiftTo(L, H) } while (K.signum() > 0) { if ((J = K.getLowestSetBit()) > 0) { K.rShiftTo(J, K) } if ((J = H.getLowestSetBit()) > 0) { H.rShiftTo(J, H) } if (K.compareTo(H) >= 0) { K.subTo(H, K); K.rShiftTo(1, K) } else { H.subTo(K, H); H.rShiftTo(1, H) } } if (L > 0) { H.lShiftTo(L, H) } return H } function bnpModInt(F) { if (F <= 0) { return 0 } var H = this.DV % F, G = (this.s < 0) ? F - 1 : 0; if (this.t > 0) { if (H == 0) { G = this[0] % F } else { for (var E = this.t - 1; E >= 0; --E) { G = (H * G + this[E]) % F } } } return G } function bnModInverse(O) { var L = O.isEven(); if ((this.isEven() && L) || O.signum() == 0) { return BigInteger.ZERO } var K = O.clone(), J = this.clone(); var N = nbv(1), P = nbv(0), M = nbv(0), I = nbv(1); while (K.signum() != 0) { while (K.isEven()) { K.rShiftTo(1, K); if (L) { if (!N.isEven() || !P.isEven()) { N.addTo(this, N); P.subTo(O, P) } N.rShiftTo(1, N) } else { if (!P.isEven()) { P.subTo(O, P) } } P.rShiftTo(1, P) } while (J.isEven()) { J.rShiftTo(1, J); if (L) { if (!M.isEven() || !I.isEven()) { M.addTo(this, M); I.subTo(O, I) } M.rShiftTo(1, M) } else { if (!I.isEven()) { I.subTo(O, I) } } I.rShiftTo(1, I) } if (K.compareTo(J) >= 0) { K.subTo(J, K); if (L) { N.subTo(M, N) } P.subTo(I, P) } else { J.subTo(K, J); if (L) { M.subTo(N, M) } I.subTo(P, I) } } if (J.compareTo(BigInteger.ONE) != 0) { return BigInteger.ZERO } if (I.compareTo(O) >= 0) { return I.subtract(O) } if (I.signum() < 0) { I.addTo(O, I) } else { return I } if (I.signum() < 0) { return I.add(O) } else { return I } } var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]; var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]; function bnIsProbablePrime(F) { var J, I = this.abs(); if (I.t == 1 && I[0] <= lowprimes[lowprimes.length - 1]) { for (J = 0; J < lowprimes.length; ++J) { if (I[0] == lowprimes[J]) { return true } } return false } if (I.isEven()) { return false } J = 1; while (J < lowprimes.length) { var H = lowprimes[J], G = J + 1; while (G < lowprimes.length && H < lplim) { H *= lowprimes[G++] } H = I.modInt(H); while (J < G) { if (H % lowprimes[J++] == 0) { return false } } } return I.millerRabin(F) } function bnpMillerRabin(J) { var I = this.subtract(BigInteger.ONE); var O = I.getLowestSetBit(); if (O <= 0) { return false } var L = I.shiftRight(O); J = (J + 1) >> 1; if (J > lowprimes.length) { J = lowprimes.length } var N = nbi(); for (var P = 0; P < J; ++P) { N.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]); var M = N.modPow(L, this); if (M.compareTo(BigInteger.ONE) != 0 && M.compareTo(I) != 0) { var K = 1; while (K++ < O && M.compareTo(I) != 0) { M = M.modPowInt(2, this); if (M.compareTo(BigInteger.ONE) == 0) { return false } } if (M.compareTo(I) != 0) { return false } } } return true } BigInteger.prototype.chunkSize = bnpChunkSize; BigInteger.prototype.toRadix = bnpToRadix; BigInteger.prototype.fromRadix = bnpFromRadix; BigInteger.prototype.fromNumber = bnpFromNumber; BigInteger.prototype.bitwiseTo = bnpBitwiseTo; BigInteger.prototype.changeBit = bnpChangeBit; BigInteger.prototype.addTo = bnpAddTo; BigInteger.prototype.dMultiply = bnpDMultiply; BigInteger.prototype.dAddOffset = bnpDAddOffset; BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo; BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo; BigInteger.prototype.modInt = bnpModInt; BigInteger.prototype.millerRabin = bnpMillerRabin; BigInteger.prototype.clone = bnClone; BigInteger.prototype.intValue = bnIntValue; BigInteger.prototype.byteValue = bnByteValue; BigInteger.prototype.shortValue = bnShortValue; BigInteger.prototype.signum = bnSigNum; BigInteger.prototype.toByteArray = bnToByteArray; BigInteger.prototype.equals = bnEquals; BigInteger.prototype.min = bnMin; BigInteger.prototype.max = bnMax; BigInteger.prototype.and = bnAnd; BigInteger.prototype.or = bnOr; BigInteger.prototype.xor = bnXor; BigInteger.prototype.andNot = bnAndNot; BigInteger.prototype.not = bnNot; BigInteger.prototype.shiftLeft = bnShiftLeft; BigInteger.prototype.shiftRight = bnShiftRight; BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit; BigInteger.prototype.bitCount = bnBitCount; BigInteger.prototype.testBit = bnTestBit; BigInteger.prototype.setBit = bnSetBit; BigInteger.prototype.clearBit = bnClearBit; BigInteger.prototype.flipBit = bnFlipBit; BigInteger.prototype.add = bnAdd; BigInteger.prototype.subtract = bnSubtract; BigInteger.prototype.multiply = bnMultiply; BigInteger.prototype.divide = bnDivide; BigInteger.prototype.remainder = bnRemainder; BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder; BigInteger.prototype.modPow = bnModPow; BigInteger.prototype.modInverse = bnModInverse; BigInteger.prototype.pow = bnPow; BigInteger.prototype.gcd = bnGCD; BigInteger.prototype.isProbablePrime = bnIsProbablePrime; BigInteger.prototype.square = bnSquare; function Arcfour() { this.i = 0; this.j = 0; this.S = new Array() } function ARC4init(H) { var F, E, G; for (F = 0; F < 256; ++F) { this.S[F] = F } E = 0; for (F = 0; F < 256; ++F) { E = (E + this.S[F] + H[F % H.length]) & 255; G = this.S[F]; this.S[F] = this.S[E]; this.S[E] = G } this.i = 0; this.j = 0 } function ARC4next() { var B; this.i = (this.i + 1) & 255; this.j = (this.j + this.S[this.i]) & 255; B = this.S[this.i]; this.S[this.i] = this.S[this.j]; this.S[this.j] = B; return this.S[(B + this.S[this.i]) & 255] } Arcfour.prototype.init = ARC4init; Arcfour.prototype.next = ARC4next; function prng_newstate() { return new Arcfour() } var rng_psize = 256; var rng_state; var rng_pool; var rng_pptr; function rng_seed_int(B) { rng_pool[rng_pptr++] ^= B & 255; rng_pool[rng_pptr++] ^= (B >> 8) & 255; rng_pool[rng_pptr++] ^= (B >> 16) & 255; rng_pool[rng_pptr++] ^= (B >> 24) & 255; if (rng_pptr >= rng_psize) { rng_pptr -= rng_psize } } function rng_seed_time() { rng_seed_int(new Date().getTime()) } if (rng_pool == null) { rng_pool = new Array(); rng_pptr = 0; var t; if (window.crypto && window.crypto.getRandomValues) { var ua = new Uint8Array(32); window.crypto.getRandomValues(ua); for (t = 0; t < 32; ++t) { rng_pool[rng_pptr++] = ua[t] } } if (navigator.appName == "Netscape" && navigator.appVersion < "5" && window.crypto) { var z = window.crypto.random(32); for (t = 0; t < z.length; ++t) { rng_pool[rng_pptr++] = z.charCodeAt(t) & 255 } } while (rng_pptr < rng_psize) { t = Math.floor(65536 * Math.random()); rng_pool[rng_pptr++] = t >>> 8; rng_pool[rng_pptr++] = t & 255 } rng_pptr = 0; rng_seed_time() } function rng_get_byte() { if (rng_state == null) { rng_seed_time(); rng_state = prng_newstate(); rng_state.init(rng_pool); for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) { rng_pool[rng_pptr] = 0 } rng_pptr = 0 } return rng_state.next() } function rng_get_bytes(C) { var D; for (D = 0; D < C.length; ++D) { C[D] = rng_get_byte() } } function SecureRandom() { } SecureRandom.prototype.nextBytes = rng_get_bytes; function parseBigInt(C, D) { return new BigInteger(C, D) } function linebrk(F, G) { var E = ""; var H = 0; while (H + G < F.length) { E += F.substring(H, H + G) + "\n"; H += G } return E + F.substring(H, F.length) } function byte2Hex(B) { if (B < 16) { return "0" + B.toString(16) } else { return B.toString(16) } } function pkcs1pad2(L, M) { if (M < L.length + 11) { alert("Message too long for RSA"); return null } var K = new Array(); var N = L.length - 1; while (N >= 0 && M > 0) { var I = L.charCodeAt(N--); if (I < 128) { K[--M] = I } else { if ((I > 127) && (I < 2048)) { K[--M] = (I & 63) | 128; K[--M] = (I >> 6) | 192 } else { K[--M] = (I & 63) | 128; K[--M] = ((I >> 6) & 63) | 128; K[--M] = (I >> 12) | 224 } } } K[--M] = 0; var H = new SecureRandom(); var J = new Array(); while (M > 2) { J[0] = 0; while (J[0] == 0) { H.nextBytes(J) } K[--M] = J[0] } K[--M] = 2; K[--M] = 0; return new BigInteger(K) } function RSAKey() { this.n = null; this.e = 0; this.d = null; this.p = null; this.q = null; this.dmp1 = null; this.dmq1 = null; this.coeff = null } function RSASetPublic(D, C) { if (D != null && C != null && D.length > 0 && C.length > 0) { this.n = parseBigInt(D, 16); this.e = parseInt(C, 16) } else { alert("Invalid RSA public key") } } function RSADoPublic(B) { return B.modPowInt(this.e, this.n) } function RSAEncrypt(F) { var G = pkcs1pad2(F, (this.n.bitLength() + 7) >> 3); if (G == null) { return null } var E = this.doPublic(G); if (E == null) { return null } var H = E.toString(16); if ((H.length & 1) == 0) { return H } else { return "0" + H } } RSAKey.prototype.doPublic = RSADoPublic; RSAKey.prototype.setPublic = RSASetPublic; RSAKey.prototype.encrypt = RSAEncrypt; function pkcs1unpad2(L, J) { var H = L.toByteArray(); var K = 0; while (K < H.length && H[K] == 0) { ++K } if (H.length - K != J - 1 || H[K] != 2) { return null } ++K; while (H[K] != 0) { if (++K >= H.length) { return null } } var G = ""; while (++K < H.length) { var I = H[K] & 255; if (I < 128) { G += String.fromCharCode(I) } else { if ((I > 191) && (I < 224)) { G += String.fromCharCode(((I & 31) << 6) | (H[K + 1] & 63)); ++K } else { G += String.fromCharCode(((I & 15) << 12) | ((H[K + 1] & 63) << 6) | (H[K + 2] & 63)); K += 2 } } } return G } function RSASetPrivate(D, E, F) { if (D != null && E != null && D.length > 0 && E.length > 0) { this.n = parseBigInt(D, 16); this.e = parseInt(E, 16); this.d = parseBigInt(F, 16) } else { alert("Invalid RSA private key") } } function RSASetPrivateEx(M, O, N, D, P, C, E, L) { if (M != null && O != null && M.length > 0 && O.length > 0) { this.n = parseBigInt(M, 16); this.e = parseInt(O, 16); this.d = parseBigInt(N, 16); this.p = parseBigInt(D, 16); this.q = parseBigInt(P, 16); this.dmp1 = parseBigInt(C, 16); this.dmq1 = parseBigInt(E, 16); this.coeff = parseBigInt(L, 16) } else { alert("Invalid RSA private key") } } function RSAGenerate(Q, L) { var B = new SecureRandom(); var O = Q >> 1; this.e = parseInt(L, 16); var N = new BigInteger(L, 16); for (; ;) { for (; ;) { this.p = new BigInteger(Q - O, 1, B); if (this.p.subtract(BigInteger.ONE).gcd(N).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) { break } } for (; ;) { this.q = new BigInteger(O, 1, B); if (this.q.subtract(BigInteger.ONE).gcd(N).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) { break } } if (this.p.compareTo(this.q) <= 0) { var M = this.p; this.p = this.q; this.q = M } var P = this.p.subtract(BigInteger.ONE); var E = this.q.subtract(BigInteger.ONE); var R = P.multiply(E); if (R.gcd(N).compareTo(BigInteger.ONE) == 0) { this.n = this.p.multiply(this.q); this.d = N.modInverse(R); this.dmp1 = this.d.mod(P); this.dmq1 = this.d.mod(E); this.coeff = this.q.modInverse(this.p); break } } } function RSADoPrivate(F) { if (this.p == null || this.q == null) { return F.modPow(this.d, this.n) } var D = F.mod(this.p).modPow(this.dmp1, this.p); var E = F.mod(this.q).modPow(this.dmq1, this.q); while (D.compareTo(E) < 0) { D = D.add(this.p) } return D.subtract(E).multiply(this.coeff).mod(this.p).multiply(this.q).add(E) } function RSADecrypt(E) { var D = parseBigInt(E, 16); var F = this.doPrivate(D); if (F == null) { return null } return pkcs1unpad2(F, (this.n.bitLength() + 7) >> 3) } RSAKey.prototype.doPrivate = RSADoPrivate; RSAKey.prototype.setPrivate = RSASetPrivate; RSAKey.prototype.setPrivateEx = RSASetPrivateEx; RSAKey.prototype.generate = RSAGenerate; RSAKey.prototype.decrypt = RSADecrypt; var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; var b64padchar = "="; function hex2b64(A) { var B; var D; var C = ""; for (B = 0; B + 3 <= A.length; B += 3) { D = parseInt(A.substring(B, B + 3), 16); C += b64map.charAt(D >> 6) + b64map.charAt(D & 63) } if (B + 1 == A.length) { D = parseInt(A.substring(B, B + 1), 16); C += b64map.charAt(D << 2) } else { if (B + 2 == A.length) { D = parseInt(A.substring(B, B + 2), 16); C += b64map.charAt(D >> 2) + b64map.charAt((D & 3) << 4) } } while ((C.length & 3) > 0) { C += b64padchar } return C } function b64tohex(B) { var C = ""; var A; var E = 0; var D; for (A = 0; A < B.length; ++A) { if (B.charAt(A) == b64padchar) { break } v = b64map.indexOf(B.charAt(A)); if (v < 0) { continue } if (E == 0) { C += int2char(v >> 2); D = v & 3; E = 1 } else { if (E == 1) { C += int2char((D << 2) | (v >> 4)); D = v & 15; E = 2 } else { if (E == 2) { C += int2char(D); C += int2char(v >> 2); D = v & 3; E = 3 } else { C += int2char((D << 2) | (v >> 4)); C += int2char(v & 15); E = 0 } } } } if (E == 1) { C += int2char(D << 2) } return C } function b64toBA(C) { var A = b64tohex(C); var B; var D = new Array(); for (B = 0; 2 * B < A.length; ++B) { D[B] = parseInt(A.substring(2 * B, 2 * B + 2), 16) } return D };
function bigintToText(d) {
    var b = d.toByteArray();
    var i = -1;
    var ret = "";
    while (++i < b.length) {
        var c = b[i] & 255;
        if (c < 128) { // utf-8 decode
            ret += String.fromCharCode(c);
        }
        else if ((c > 191) && (c < 224)) {
            ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));
            ++i;
        }
        else {
            ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));
            i += 2;
        }
    }
    return ret;
}
function bigintToText2(text) {
    if (text == undefined) { return ""; }
    if (text.length <= 172) {
        return b64tohex(text);
    } else {
        return b64tohex(text.substr(0, 172)) + bigintToText2(text.substr(172));
    }
}


function RSADecrypt2(ctext, N, E) {
    var n = parseBigInt(N, 16);
    var e = parseBigInt(E, 16);
    var c = parseBigInt(ctext, 16);
    var m = c.modPow(e, n);
    if (m == null) return null;
    return bigintToText(m);
}
RSAKey.prototype.decrypt2 = RSADecrypt2;

function rsa(ctext, N, E) { var D = new RSAKey(); D.setPublic(N, E); res = D.encrypt(ctext); return hex2b64(res) };
function rsaD(ctext, N, E) { var r = new RSAKey(); return r.decrypt2(ctext, N, E); }
function rsaText(text, n, e) {
    if (text == undefined) { return ""; }
    if (text.length <= 110) {
        return rsa(text, n, e);
    } else {
        return rsaText(text.substr(0, 110), n, e) + rsaText(text.substr(110), n, e);
    }
}
function rsaDText(text, n, e) {
    if (text == undefined) { return ""; }
    if (text.length <= 256) {
        return rsaD(text, n, e);
    } else {
        return rsaD(text.substr(0, 256), n, e) + rsaDText(text.substr(256), n, e);
    }
}

var $rsa_n, $rsa_e;
function initRsa(n, e) { $rsa_n = n; $rsa_e = e; }

function rsaPost(url, data, appendData, callback, errCallback) {
    if (jQuery.isFunction(data)) { errCallback = errCallback || appendData; callback = data; data = undefined; appendData = undefined; }
    else if (jQuery.isFunction(appendData)) { errCallback = errCallback || callback; callback = appendData; appendData = undefined; }

    if (data != undefined) { if (typeof (data) === "string") { if (data.substr(0, 1) == "#") { data = $(data).serialize(); } } else { data = jQuery.param(data, undefined); } }
    if (appendData != undefined) { appendData = jQuery.param(appendData, undefined); if (data.length > 0) { data += "&" + appendData; } }

    var post = { data: rsaText(data, $rsa_n, $rsa_e) };

    $.ajax({
        type: "POST",
        url: url,
        data: post,
        dataType: "JSON",
        headers: {'encrypt': 'rsa'},
        success: function (data, textStatus, jqXHR) {
            if (callback != undefined) {
                //var text = rsaDText(bigintToText2(data.data), $rsa_n, $rsa_e);
                callback(data, textStatus, jqXHR);
            }
        },
        error: function (data, textStatus, errorThrown) {
            if (errCallback != undefined) {
                errCallback(data, textStatus, errorThrown);
            }
        }
    });
}
